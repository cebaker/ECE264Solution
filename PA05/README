------------------------------------------------------------------
ECE 264 - SUMMER 2013 - PROGRAMMING ASSIGNMENT 05
------------------------------------------------------------------
(Derived from an assignment by Professor Vijay Raghunathan)

INTRODUCTION
============
You will base your utilities on the widely used algorithmic technique
of Huffman coding, which is used in JPEG compression as well as in MP3
audio compression. For more information, please see the attached PDF file from last semester.

ASSIGNMENT
==========
Write a program that takes a compressed file, reads the Huffman tree
specified by the header, and decompresses the file. Hint: the header can be either character-based representation or bit-based representation. See the input files to understand what that means.

SPECIFICATIONS
============== 
There will not be a skeleton provided for this assignment.  It will be
up to you to define all functions.  In the directory PA05, there will be different files for you to start. pa05.c is for you to write your main function. utility.c is for you to write your utility functions(all the functions except main funtion). pa05.h is for you to declare all the functions and structures. A Makefile will be provided later on for your testing convenience. Even without the Makefile, you should be able to write a simple Makefile for testing purpose.

*The program takes two input arguments:
 1. the input filename of the compressed file; and
 2. the output filename for the uncompressed file.

  - A suite of inputs and their expected outputs.

Here are some other specifications for this program:

* The program takes one input argument as the compressed file. If this
  input filename is not provided, the program prints an error message
  and terminates with return value EXIT_FAILURE.  If the file cannot
  be opened, it also prints an error message and returns EXIT_FAILURE.
  This constant is defined in stdlib.h and your program needs to
  include that header file.

* Your program will read the file header, build the Huffman tree, and
  finally call Huff_postOrderPrint to generate the required output.

* Your program should be able to handle both character header and bit 	int order to get full score for this assignment.

* Be wary of memory leaks!  Remember to completely deallocate your
  Huffman tree at the end of your program.
 
 
SAMPLE OUTPUT
=============

Consider the compressed file for string "streets are stone stars are
not", the output file of the program should read as follows:

Left
Left
Left
Back
Right
Back
Leaf: t
Back
Right
Left
Left
Back
Right
Back
Leaf: a
Back
Right
Left
Back
Right
Back
Leaf: r
Back
Back
Back
Right
Left
Left
Left
Left
Back
Right
Back
Leaf: n
Back
Right
Left
Back
Right
Back
Leaf: o
Back
Back
Right
Left
Back
Right
Back
Leaf:  
Back
Back
Right
Left
Left
Back
Right
Back
Leaf: e
Back
Right
Left
Back
Right
Back
Leaf: s
Back
Back
Back
Back
 
Consider the compressed file for string "go go gophers", the output
file of the program should read as follows:

Left
Left
Left
Back
Right
Back
Leaf: g
Back
Right
Left
Back
Right
Back
Leaf: o
Back
Back
Right
Left
Left
Left
Back
Right
Back
Leaf: s
Back
Right
Left
Back
Right
Back
Leaf:  
Back
Back
Right
Left
Left
Left
Back
Right
Back
Leaf: e
Back
Right
Left
Back
Right
Back
Leaf: h
Back
Back
Right
Left
Left
Back
Right
Back
Leaf: p
Back
Right
Left
Back
Right
Back
Leaf: r
Back
Back
Back
Back
Back


HINTS
=====

* You need to use structures for this assignment.  See tree.h for the
  Huffman node structure.

* A stack is a last-in first-out (LIFO) data structure that is very
  similar to a linked list, but it has three special operations:
  
  - push: place a new item (a Huffman subtree?) on the top of the
    stack, making this the new top.

  - peek: access the item (the Huffman subtree?) at the top of the
    stack, but does not change the stack.

  - pop: removes (and deallocates) the topmost element of the stack,
    making the next element the new top.

  It is also highly likely that you need a function to check the
  number of elements currently on the stack.

* We will check whether your program initializes all pointers to NULL.
  This can be accomplished in the following ways.

  - int * ptr = NULL; /* initialized to NULL, required */
  - int * ptr; 
  - ptr = NULL; /* immediately after declaring ptr */
  - int * ptr = malloc(numberElement * sizeof(int));

  If you write the following code without initialization, you will
  lose points.

  - int * ptr; /* uninitialized pointer. NOT ALLOWED */

  Why do we check this? Uninitializing pointers make a program's
  behavior unpredictable.

  (You are also allowed to declare and allocate memory for a pointer
  immediately using malloc() or calloc().)


WHAT TO SUBMIT?
===============

Submit a .zip file containing the following files: 

1. pa05.c pa05.h utility.c.

3. A README file that describes the algorithm used in your assignment.
   The README should say how the functions accomplish their goals, not
   just the goals themselves.
 

HOW TO SUBMIT?
==============
 
Your submission should be submitted through Blackboard.  You can
submit as many times on Blackboard as you need before the deadline. We
will grade the final submission, so please make sure that it is your
FINAL version with everything included.


HOW WILL WE GRADE YOUR SUBMISSION?
==================================
 
We will grade your assignments on algorithm correctness through DDD,
memory allocation and deletions through valgrind, proper coding
standards, content of README, a proper Makefile, and commenting.
 
ADDTIONAL FAQ
=============

1. What should I write in pa05.c?
You should write your main function in pa05.c. This main function should call the utility functions you write in utility.c to open the input, read the header, generate the Huffman Tree, and use post order print to an output file(See Makefile).

2. What are the tree.c and tree.h?
The tree.h is the header file for tree.c. The tree.c contains a function void Huff_postOrderPrint(HuffNode *tree), You should refer to this and write your own post order print function since you are writing your output to a file. In short, you should open an output file and use fprintf to do that. You should not submit tree.c and tree.h.
